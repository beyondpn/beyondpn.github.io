<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://localhost:4000</id>
    <title>BeyondPN</title>
    <updated>2020-06-24T11:27:37.799Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="http://localhost:4000"/>
    <link rel="self" href="http://localhost:4000/atom.xml"/>
    <subtitle>BE REAL, BE FREE</subtitle>
    <logo>http://localhost:4000/images/avatar.png</logo>
    <icon>http://localhost:4000/favicon.ico</icon>
    <rights>All rights reserved 2020, BeyondPN</rights>
    <entry>
        <title type="html"><![CDATA[数据库连接的重连]]></title>
        <id>http://localhost:4000/post/reconnect_config/</id>
        <link href="http://localhost:4000/post/reconnect_config/">
        </link>
        <updated>2020-06-24T10:05:26.000Z</updated>
        <summary type="html"><![CDATA[<p>每次项目上线前都必然会确认下数据库，redis 的断线重连机制，由于事关重大，每次都要查询资料，浪费了很多时间。这次查询后在这里记录一下，作为一个检查表，避免下次再麻烦。</p>
]]></summary>
        <content type="html"><![CDATA[<p>每次项目上线前都必然会确认下数据库，redis 的断线重连机制，由于事关重大，每次都要查询资料，浪费了很多时间。这次查询后在这里记录一下，作为一个检查表，避免下次再麻烦。</p>
<h2 id="-more-"><!-- more --></h2>
<h3 id="mysql-的断线重连">MySQL 的断线重连</h3>
<p>MySQL 的 jdbc 连接字符串支持配置断线重连 <code>autoReconnect=true</code>，但是这种配置方式并不推荐，因为有副作用，文档节选如下：</p>
<blockquote>
<p><strong>autoReconnect</strong></p>
<p>Should the driver try to re-establish stale and/or dead connections? If enabled the driver will throw an exception for a queries issued on a stale or dead connection, which belong to the current transaction, but will attempt reconnect before the next query issued on the connection in a new transaction. The use of this feature is not recommended, because it has side effects related to session state and data consistency when applications don't handle SQLExceptions properly, and is only designed to be used when you are unable to configure your application to handle SQLExceptions resulting from dead and stale connections properly. Alternatively, as a last option, investigate setting the MySQL server variable &quot;wait_timeout&quot; to a high value, rather than the default of 8 hours.</p>
<p>Default: false</p>
<p>https://dev.mysql.com/doc/connector-j/5.1/en/connector-j-reference-configuration-properties.html</p>
</blockquote>
<p>所以，MySQL 的断线重连使用连接池的相关配置实现，我查看了 Alibaba Druid 和 Hikari 的配置，大同小异，即通过配置一个检测 SQL 来判断连接是否有效，如无效，则从连接池剔除。所谓重连只是从连接池 borrow 时重新创建一个连接即可。</p>
<p>配合 testWhileIdle 检测空闲连接的可用性，避免 MySQL 服务器端超时导致报错。</p>
<p>Druid 配置：</p>
<pre><code class="language-xml">    &lt;property name=&quot;druid.validationQuery&quot; value=&quot;SELECT 'x'&quot;/&gt;
    &lt;property name=&quot;druid.testWhileIdle&quot; value=&quot;true&quot;/&gt;
    &lt;property name=&quot;druid.testOnBorrow&quot; value=&quot;false&quot;/&gt;
    &lt;property name=&quot;druid.testOnReturn&quot; value=&quot;false&quot;/&gt;
</code></pre>
<p>Spring Boot 配置：</p>
<pre><code class="language-properties">    spring.datasource.testWhileIdle = true
    spring.datasource.timeBetweenEvictionRunsMillis = 60000
    spring.datasource.validationQuery = SELECT 1
</code></pre>
<hr>
<h3 id="redis-的断线重连">Redis 的断线重连</h3>
<p>项目使用的客户端时 lettuce，直接在代码里设置重连即可。默认重连间隔从1秒开始翻倍延长，最大30秒。</p>
<pre><code class="language-java">client.setOptions(ClientOptions.builder()
                .autoReconnect(true)
                .socketOptions(SocketOptions.builder()
                        .keepAlive(true)
                        .tcpNoDelay(true)
                        .build()
                )
                .build());
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[说说 ThreadLocal]]></title>
        <id>http://localhost:4000/post/threadlocal/</id>
        <link href="http://localhost:4000/post/threadlocal/">
        </link>
        <updated>2020-04-26T12:46:39.000Z</updated>
        <summary type="html"><![CDATA[<p>按照编码建议将 ThreadLocal 对象声明为 <code>static</code> 的，正常使用 ThreadLocal 即可.</p>
]]></summary>
        <content type="html"><![CDATA[<p>按照编码建议将 ThreadLocal 对象声明为 <code>static</code> 的，正常使用 ThreadLocal 即可.</p>
<!-- more -->
<p>前两天看同事的代码，同事提了一句说</p>
<blockquote>
<p>ThreadLocal 的 map 的 Entry 是 WeakReference，所以会出现 ThreadLocal 对象被 GC 释放的问题，故他在代码中使用 ThreadLocal 时考虑了这个情况，不会出现问题。</p>
</blockquote>
<p>闻之大惊，因为我这么多年使用 ThreadLocal 从未考虑过这种情况，细一考量会发现如果真是这样的话，ThreadLocal 的使用场景就几乎不太存在了。直觉上感觉应该是他哪里理解错了。</p>
<p>今天有时间，就深究了一下这个问题。</p>
<p><strong>先说结论，上面的说法确实理解有误，按照编码建议将 ThreadLocal 对象声明为 <code>static</code> 的，正常使用 ThreadLocal 即可。</strong></p>
<hr>
<p>以下是探究过程。</p>
<p>首先写了一个例子：</p>
<pre><code class="language-java">public class ThreadLocalTest {

    private static final ThreadLocal&lt;Map&lt;String, String&gt;&gt; holder = ThreadLocal.withInitial(HashMap::new);
    private static final List&lt;ThreadLocal&lt;Integer&gt;&gt; holderList = new ArrayList&lt;&gt;();

    public static void main(String[] args) {
        init(10000, 10000);
        gc();
        initHolders(10000);
        gc();
        System.out.println(holder.get().size());
        checkHolderList();
    }

    private static void gc() {
        System.out.println(&quot;gc goes here ...&quot;);
        System.gc();
    }

    private static void init(int size, int valueLength) {
        for (int i = 0; i &lt; size; i++) {
            holder.get().put(String.valueOf(i), RandomStringUtils.random(valueLength));
        }
    }

    private static void initHolders(int size) {
        for (int i = 0; i &lt; size; i++) {
            ThreadLocal&lt;Integer&gt; holder = new ThreadLocal&lt;&gt;();
            holderList.add(holder);
            holder.set(i);
        }
    }

    private static void checkHolderList() {
        System.out.println(holderList.size());
        for (int i = 0; i &lt; holderList.size(); i++) {
            if (holderList.get(i).get() != i) {
                throw new RuntimeException(&quot;check failed&quot;);
            }
        }
        System.out.println(&quot;check success&quot;);
    }
}

//java ThreadLocalTest -verbose:gc
</code></pre>
<p>运行后未发现任何问题，如果将 ThreadLocal 换成 WeakReference，则测试无法运行。</p>
<p>那是什么原因导致的呢？看代码。</p>
<p>同事说的 ThreadLocal 中 Entry 为 WeakReference 的代码如下：</p>
<pre><code class="language-java">// TheadLocal.ThreadLocalMap.Entry
/**
         * The entries in this hash map extend WeakReference, using
         * its main ref field as the key (which is always a
         * ThreadLocal object).  Note that null keys (i.e. entry.get()
         * == null) mean that the key is no longer referenced, so the
         * entry can be expunged from table.  Such entries are referred to
         * as &quot;stale entries&quot; in the code that follows.
         */
        static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; {
            /** The value associated with this ThreadLocal. */
            Object value;

            Entry(ThreadLocal&lt;?&gt; k, Object v) {
                super(k);
                value = v;
            }
        }
</code></pre>
<p>这里要注意，WeakReference 引用的对象是 ThreadLocal，也就是说只要你保持对 ThreadLocal 对象的引用，就不会被清除掉。而这里使用 WeakReference 的原因，也写的很清除了，主要是避免在 ThreadLocal 对象被清理的情况下发生内存泄漏。如果 ThreadLocal 对象被清理了，Thread 的成员变量 <code>ThreadLocal.ThreadLocalMap threadLocals</code> 会在 gc 时清理掉这些对象，避免内存泄漏。</p>
<p>另外，jdk 的实现中 ThreadLocal 设计为由 <code>Thread</code> 持有以 <code>ThreadLocal</code>为 key 的 <code>ThreadLocalMap</code> ，而不是由 <code>ThreadLocal</code> 对象持有以 <code>Thread</code> 为 key 的 <code>ThreadLocalMap</code> 也是处于避免内存泄漏的考虑。因为大部分情况下 Thread 的生命周期会短于 <code>ThreadLocal</code> 的生命周期。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[改 5 个字符修了一个 bug]]></title>
        <id>http://localhost:4000/post/fix-a-bug-within-five-char/</id>
        <link href="http://localhost:4000/post/fix-a-bug-within-five-char/">
        </link>
        <updated>2016-11-25T16:50:54.000Z</updated>
        <summary type="html"><![CDATA[<p>切记不要简单的望文生义。</p>
]]></summary>
        <content type="html"><![CDATA[<p>切记不要简单的望文生义。</p>
<!-- more -->
<p>公司决定赌一把，把所有项目组撤销合并到《石器时代》里，毕竟腾讯发行，希望很大。石器的代码源自新仙剑，是 c# 和 c++ 编写的。当时我在上家公司做平台的时候，奎斌写了服务器的第一版，依然怀念每天一起去华师大吃饭扯皮的日子。</p>
<p>之后几经辗转，换了几批人，这些满是补丁的代码成了石器的服务端基础代码。代码年久失修，所以前段时间他们决定用 netty 重写网关，我加入的时候这个新版网关正在测试。测试反馈了一个 bug，压力测试环境中，机器人全部杀掉之后，有部分机器人没有下线。我相对清闲，又是公司第一个用 netty 写服务端的，于是去解决这个 bug。从表现看，正常下线和不正常下线的机器人都有，比较符合并发 bug 的表现，于是去翻代码，特别注意有并发的部分。</p>
<p>机器人下线的代码是这么写的。</p>
<pre><code class="language-java">public void channelInactive(ChannelHandlerContext ctx) throws Exception {
        DisconnectMessage disconnect = new DisconnectMessage(); 
        //... other code queue.offerMessage(disconnect); 
} 
</code></pre>
<p>queue 部分的代码是这样的</p>
<pre><code class="language-java">private ReadWriteLock rwLock = new ReetrantReadWriteLock();

public boolean offerMessage(Message msg) { 、
    Lock l = rwLock.readLock(); // bug is here 
    l.lock(); 
    try { 
        queue.offer(msg); 
    } finally { 
        l.unlock(); 
    } 
}

public Queue getMessageQueue() { 
    if(queue.isEmpty()) { 
        return null; 
    } 
    Queue rtn = new LinkedList&lt;&gt;();
    Lock l = rwLock.writeLock(); 
    l.lock(); 
    try { 
        rtn.addAll(queue); 
        queue.clear(); 
    } finally { 
        l.unlock(); 
    } 
    return rtn; 
} 
</code></pre>
<p>bug 找到了，跟预期一直，并发问题。写这段代码的人不熟悉 java 的锁又没有仔细看文档，写出了 bug 代码，简单修改下，把 readLock 改成 writeLock 就可以了。修改 5 个字符，改掉一个 bug，感觉还是很爽的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[也谈谈医疗改革]]></title>
        <id>http://localhost:4000/post/health-care/</id>
        <link href="http://localhost:4000/post/health-care/">
        </link>
        <updated>2016-10-26T11:59:48.000Z</updated>
        <summary type="html"><![CDATA[<p>毒瘤要切掉，最终解决问题还是得技术进步。</p>
]]></summary>
        <content type="html"><![CDATA[<p>毒瘤要切掉，最终解决问题还是得技术进步。</p>
<!-- more -->
<p>前几天看到连岳写的一篇文章，<a href="https://mp.weixin.qq.com/s?src=3&amp;timestamp=1477480477&amp;ver=1&amp;signature=A*ITBFB6b3tsFG2Ty6b4t*Kq6NxSb2rrQT5lhUeO8LaPPO4aAGC2MzwVjAtSJ9topO4FHC6aO8v7tlYqDGMpHrhvsGzgODl8ygOlj8tkeJ4j5cQdzQIquLXUStqXF9knIp209VWB16GvHYVU5MEeh-SdDNu2g0EmFOD8muvm3AU=">祝民营医院挖光儿科医生</a>，而我做父亲一年半来带女儿看病的经历也让我对这一块有切身感受。</p>
<h3 id="一">一</h3>
<p>女儿一岁半，生过几次病，出生时黄疸一次，腹泻一次，感冒咳嗽几次，还有一次是因为我这个不合格的父亲导致头破了。</p>
<p>麻烦的是咳嗽，一般发病流程是这样的。先是咳嗽，去医院检查一下就是喉咙发炎，然后医生开些药吃，运气好的话起效就结束了，运气不好，再去看的时候就是支气管炎，这时候很危险，搞不好会发展成肺炎。</p>
<p>女儿看病的医院，之前住的地方离上海儿童医院比较近，都是直接去儿童医院，后来搬到现在住的地方，一般先去华山医院宝山分院儿科去看，这是个二甲医院，不行再去儿童医院（路途很折腾，算上堵车，路上很容易就花一个小时时间）。</p>
<p>再说说医生，儿童医院有两种价格，88的专家号和18的普通号，还有特需门诊，一般是300。家附近的华山宝山分院好像专家和普通都是十几块。而我因为比较穷，大部分情况是选择88的，只有一次周六去看病，没有88的专家可选，去看了一次特需。也看过几次普通门诊。</p>
<p>先说说感受，医生态度基本上还是可以的，比其它科室的要好一些。猜测一方面是因为儿科大部分都是些感冒，发烧，腹泻的常见病，另一方面是小孩子往往不太配合，导致每个孩子的时间相对不那么短，相应的也少了一些急躁。</p>
<p>再说说检查，这一块感觉也是不错，基本上没有过度检查的事情，原因恐怕也是病情简单。</p>
<p>最后说说开药，这一块问题非常严重，主要就是中药的滥用。最好的例子是女儿黄疸时开的<a href="https://mp.weixin.qq.com/s?src=3&amp;timestamp=1477484138&amp;ver=1&amp;signature=xqV-XAGjFCQXdcaa5TtIgUWrI3Sbggzz8brCM*W0Tv*IQdw4rY3*NYn3r116IhW3qPTU6bvth19y-uFCNstl4j4CqFI*rZzpcpo99p07FtPRtyYJ8CF4ACURBXG1HKWxKNJynkaF*gDxw37rgZdk09Oht524qUt80aWCldNadEE=">茵栀黄口服液</a>（开这药的是长宁妇幼），就在不久前被卫生部禁用了。我并非中药黑，只是我不相信一个未经大样本双盲随机实验的药品是可靠的，只是很多时候完全没有选择，而信息不对称更让选择成为不可能。看咳嗽的几次经历也差不多，每次咽炎都会开清开灵颗粒，镇咳化痰口服液，有时候还会有其它乱七八糟的无效或者说负面效用不明显的中药。说这些药无效，不是我个人猜测，而是如果医生只开这些药，我会在一天后（一般都是三天后复诊）换一个医生去看，有几次医生都告诉我不要再吃这些药了。</p>
<p>这两年看到比较多的关于医生特别是儿科医生付出回报比不高的消息，我不清楚实际情况，不过十几块的挂号费确实不是一个合理的价格，这也是以药养医的根源，反应在儿科就是中药的滥用。很显然，这种迂回的收费效率低下，大量的医药费被浪费掉了，同时服务质量也非常差。</p>
<p>连岳说的市场化改革可以解决这个问题，我赞成。</p>
<h3 id="二">二</h3>
<p>我本人也是医院的常客，因为患有强直性脊柱炎，需要我定期去医院复诊。</p>
<p>每次复诊也很简单，到医院后先挂号，然后抽血验尿，一个半小时左右会检查结果出来，拿着检查结果去找医生，检查没有异样的话，医生开药，开下次检查单，拿药回家。整个看医生的过程大概就是1分钟，而化验单也很容易看懂，就几个关键指标。现在大概每50天去复诊一次，之所以是50天，是因为医保限制开药最多开一个月（医生会把每天的药量稍微开大一点，比如每天吃9片，实际每天吃6片）。对于这种典型的慢性病，在病情稳定的情况下，需要医生的地方也就开药开检查单，这些都是长久不变的东西，据我了解到的强直性脊柱炎的知识，这个病最难的是确诊，一旦确诊，治疗方案就这么多，无非是找出一个最佳的长期治疗方案，然后按照这个方案一直看下去。</p>
<p>如果将来 AI 医生正式上岗，慢性病的复诊大概应该是第一个应用的领域，这能消灭大部分的风湿科门诊需求。真到了这一天，医生的身份也从主要的执行者变成研究人员，也就不存在医疗改革的需求了。</p>
<p>技术进步才是颠覆性的。</p>
<h3 id="三">三</h3>
<p>一点补充。</p>
<p>就像周围没有人敢给孩子喝国产奶粉一样，市场化不会解决所有问题，必须有配套的制衡机制，如果没有可靠的司法制度，劣币驱逐良币是难免的。</p>
<p>特需门诊普遍好于普通门诊，除了收费高很多之外，我觉得还有一个因素就是每个医生都是一个独立的品牌，医生需要维护自己的品牌。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[HashMap 和 ArrayList 有什么区别？兼谈面试题的选择]]></title>
        <id>http://localhost:4000/post/the-difference-between-hashmap-and-arraylist/</id>
        <link href="http://localhost:4000/post/the-difference-between-hashmap-and-arraylist/">
        </link>
        <updated>2016-08-23T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>面试不是为了考到别人，是为了找到我们需要的人，面试官也要换位思考。</p>
]]></summary>
        <content type="html"><![CDATA[<p>面试不是为了考到别人，是为了找到我们需要的人，面试官也要换位思考。</p>
<!-- more -->
<blockquote>
<p>Q: HashMap 和 ArrayList 有什么区别？<br>
A: ... (一脸懵逼，这根本就是两种东西好嘛）</p>
</blockquote>
<p>朋友面试归来，跟我提及上面的面试题，问我怎么看。有什么区别？一个是 K/V 类型，一个是列表类型，除了都是 Java Collection Framework 成员，是容器外，从 API 接口看，完全没有共同点。我一时也很茫然，不知道面试官在考察什么，直到我开始想我是怎么用 ArrayList 的。</p>
<p>在游戏项目中，大量的数据是常驻内存的，比如在线玩家的数据。这就需要在内存中对这些数据集合做管理，通常是使用 HashMap 或者 ArrayList（数组）。想到这一层，这个问题开始变的有意义，只要熟悉这两个数据结构，就很容易看出区别来。我这里试着列举一些。</p>
<ul>
<li>查询 ArrayList 只能用数字索引，查询 HashMap 不限数字索引</li>
<li>数据保存到 ArrayList 必须用紧凑的索引，否则稀疏的数组会造成很大浪费，而保存到 HashMap 中空间使用效率与 key 是否稀疏无关</li>
<li>使用 ArrayList 管理数据时，一般需要维护一个实际 key 到 index 的映射，HashMap 不需要这个映射</li>
<li>为避免 hash 冲突导致的效率下降，HashMap 的空间使用率低于 ArrayList，在数据量较大时将产生比较明显的影响</li>
<li>虽然时间复杂度都是 O(1)，ArrayList 的常数时间低于 HashMap 的常数时间</li>
</ul>
<p>总体比较下来就是 ArrayList 的内存使用效率更高，但是需要编写更多代码，只有在管理大量 key 时有优势。也可以把 ArrayList 理解为只能使用连续数字索引作为 key 的 HashMap。在 php 中，map 即是数组，是一回事，但对于 Java 程序员来说，不是一下子就能想到。</p>
<h3 id="到这一步问题似乎解决了但这是一道好的面试题吗">到这一步，问题似乎解决了，但这是一道好的面试题吗？</h3>
<p>面试官认为自己提了一个简单的问题，但对于被试者来说，在短时间内一下可能一下没有想到，在简单问题上栽了跟头。这对于面试官和被试者都不是好事，毕竟面试的最终目的是找到合适的人，尽可能的让被试者展示自己的能力，才是符合目标的做法。</p>
<p>我认为做到下面这些就足够了</p>
<ol>
<li>题目是清晰的，聚焦的，而非宽泛的。过于宽泛的问题往往够写一本书，一会导致出现浑水摸鱼的情况，二会导致回答的深度不够。比如，如何对 JVM 调优 vs 游戏服务器进程堆为 4g+，如何设置参数减少 gc 时的 STW 时间。</li>
<li>题目最好从一个问题出发，询问解决方案，而不是从一个具体的结果出发，反向推出题目，这种情况容易导致背景缺失。做一个项目要很久，要尽量去除偶然因素。比如文初的这个题目，更好的问法是你是如何管理游戏中的对象的，用的什么数据结构，选择的依据和原因。</li>
<li>如果要考察实战能力，比如 debug 的能力，最好是自己解决过的线上问题。</li>
<li>如果要考察跟同事合作的能力，比如面试游戏程序员时，可以把自己想象成策划。</li>
<li>有条件的话最好当场写代码，毕竟 <code>talk is cheap</code></li>
</ol>
<p>以上做法仅适用于小的团队。</p>
]]></content>
    </entry>
</feed>